#!/usr/bin/env ruby
# Encoding: utf-8

@oldrev, @newrev, @refname = STDIN.read.split(" ")
@short_refname = @refname[11..-1]
@merge_commits = `git rev-list --merges #{@oldrev}..#{@newrev} 2> /dev/null`.strip
@parent_commit = `git rev-parse #{@newrev}\^1 2> /dev/null`
@unique_revs = `git rev-list master..#{@newrev} --not $(git rev-list --all ^#{@newrev}) 2> /dev/null` # http://stackoverflow.com/a/5724488
@missed_revs = `git rev-list master..#{@newrev} 2> /dev/null`

@rebased_revs = `git cherry \
$(git for-each-ref --format="%(refname)" refs/heads/version) \
$(git for-each-ref --format="%(refname)" refs/heads/hotfix)`.split("\n").grep(/\-/).join("\n").tr("- ","")
@hotfix_revs = `git rev-list --reverse master..$(git for-each-ref --format="%(refname)" refs/heads/hotfix)`

puts "Enforcing Policies... \n(#{@short_refname}) (#{@oldrev[0,6]}) (#{@newrev[0,6]})"

def check_branch_policy
  errors = []
  errors << "Only Version, Hotfix and Master branches are allowed to be pushed upstream." if
    !@short_refname[/^(version\/[1-9.]+|hotfix\/[1-9.]+|master)/]
  if @short_refname['master']
    # Master should have only one unique commit each time - the merge commit (@newrev).
    # => Otherwise, commits were made directly (==only) on master.
    errors << "Master branch accepts only non-forwarded merge commits, one at a time." if
      !@merge_commits[@newrev] || !@parent_commit[@oldrev]
    errors << "Hotfix branch should be both merged to master and rebased to latest version." if
      (@rebased_revs.empty? && !@hotfix_revs.empty?) || !@rebased_revs[@hotfix_revs]
  else
    # If not empty, it means there's a merge commit - whereas there shouldn't be.
    errors << "Version and Hotfix branches accept only fast-forward/rebased commits." if
      !@merge_commits.empty?
    # If not equal, it means at least one commit is reachable from another ref - meaning it was diverged.
    errors << "Version and Hotfix branches must diverge from Master branch directly." if
      !@unique_revs[@missed_revs]
  end
  errors
end
errors = check_branch_policy

unless errors.empty?
  puts '[POLICY] Invalid git branch rules.'
  errors.each { |error| puts "#    Branch #{@short_refname}: #{error}" }
  exit 1
end

# Hotfix branch must be merged both to master and rebased to current version branch
# semVer control on version/hotfix/tags
# Hotfix/* versioning format: 1.0.0-1

# SemVer Sanity Checks
# => SemVer Hotfix < Version
# => SemVer Hotfix_upstream < Hotfix_current
# => SemVer Version_upstream < Version_current

# def resolve_hotfix()
#   git checkout master
#   git merge --no-ff $@short_refname
#   git tag $@short_refname_tag

#   git rebase $current_version_branch} $@short_refname
#   git checkout $current_version_branch
#   git reset --hard $@short_refname
#   git push $current_version_branch

#   git branch -D $@short_refname} && git branch -D origin/$@short_refname
#   git branch --merged master | grep -v "master" | xargs -n 1 git branch -d
# end
