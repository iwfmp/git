#!/usr/bin/env ruby
# Encoding: utf-8

# Description  : Git hook for branch policy.
# Usage        :
# Dependencies :
# Example      :
# Notes        :
# Source       : http://stackoverflow.com/a/5724488
# Source       : https://coderwall.com/p/fytgoq

@oldrev, @newrev, @refname = STDIN.read.split(" ")
@short_refname = @refname[11..-1]
@zero = "0000000000000000000000000000000000000000"
puts "\nEnforcing Branch Policies... \n(#{@short_refname}) (#{@oldrev[0,6]}) (#{@newrev[0,6]})"

# A sure way fire to get all the merged refs, even if a branch was just created.
@merge_commits   = `git rev-list --merges #{@newrev} \^#{@oldrev} 2>/dev/null || git rev-list --merges #{@newrev} \^master 2>/dev/null`
@parent_commit   = `git rev-parse #{@newrev}\^1 2>/dev/null`
@unique_revs     = `git rev-list --no-merges #{@newrev} --not $(git for-each-ref --format="%(refname)" refs/heads | grep -Fv #{@refname}) 2>/dev/null`
@diverged_revs   = `git rev-list #{@newrev} \^master 2>/dev/null`
@branch_merged   = `git rev-list --merges #{@refname}..master 2>/dev/null`
@instance_exists = `git branch -a`[/(version\/[0-9.]+|hotfix\/[0-9.]+)/]

# -------------------------------------------------------------------------------------------------------------------------------------
# Enforce branch format rules
# -------------------------------------------------------------------------------------------------------------------------------------
def check_branch_policy
  errors = []
  errors << "Only Version, Hotfix and Master branches are allowed to be pushed upstream." if
    !@short_refname[/^(version\/[0-9.]+|hotfix\/[0-9.]+|master)/]

  if @short_refname['master']
    # (1) If newrev equals to zero, it means someone is trying to delete master branch.
    errors << "Master branch can not be deleted. WTF?" if
      @newrev[@zero]
    # (2) Master should have only one unique commit each time - the merge commit (@newrev).
    # Covers: More than one merge; More than one commit; Non-merge commit.
    errors << "Master branch accepts only non-forwarded merge commits, one at a time." if
      !@merge_commits[@newrev] || !@parent_commit[@oldrev]
    # (3) Hotfix refs should also be on version branch - if not, it means it wasn't properly rebased.
    # rebased_revs  = `git cherry $(git for-each-ref --format="%(refname)" refs/heads/version) $(git for-each-ref --format="%(refname)" refs/heads/hotfix)`
    # hotfix_revs   = `git rev-list --reverse master..$(git for-each-ref --format="%(refname)" refs/heads/hotfix)`
    # errors << "Hotfix branch should be both merged to Master and rebased on top latest Version." if
    #   (rebased_revs.empty? && !hotfix_revs.empty?) || !rebased_revs[hotfix_revs]
    # errors << "Master branch can only be merged into from Version or Hotfix branches." if

  else
    # (1) If not empty, it means there's a merge commit - whereas there shouldn't be.
    errors << "Version and Hotfix branches accept only fast-forward/rebased commits." if
      !@merge_commits.empty?
    # (2) If not empty (and was not just created) it means it has already been merged.
    errors << "Branch has already been merged. Please check to see if a new branch exists." if
      !@branch_merged.empty? && !@newrev[@zero]
    # (3) If not equal, it means at least one commit is reachable from another ref - meaning it was diverged. See links.
    errors << "Version/Hotfix branches must diverge from Master branch directly." if
      !@unique_revs[@diverged_revs]
    # (4) Allow deleting a branch only if it has already been merged to master.
    errors << "Version/Hotfix branches can not be deleted before being fully merged to Master." if
      @newrev[@zero] && @branch_merged.empty?
    # (5) If trying to create a branch, and another instance already exists, shut down everything.
    errors << "Only one Version/Hotfix branch is allowed upstream at a time." if
      @oldrev[@zero] && @instance_exists
  end

  errors
end
errors = check_branch_policy

# If new branch, ONLY 1 commit, and no other errors - always allow it.
exit 0 if @oldrev[@zero] && @parent_commit[@newrev] && errors.empty?

unless errors.empty?
  puts '[POLICY] Invalid git branch rules.'
  errors.each { |error| puts "#    Branch #{@short_refname}: #{error}" }
  exit 1
end